import React, { useCallback, useEffect, useState } from "react";
import { BrowserRouter, Switch, Route, Link } from "react-router-dom";
import "antd/dist/antd.css";
import { StaticJsonRpcProvider, JsonRpcProvider, Web3Provider } from "@ethersproject/providers";
import "./App.css";
import { message, Row, Col, Button, Menu, Alert, Switch as SwitchD } from "antd";
import Web3Modal from "web3modal";
import WalletConnectProvider from "@walletconnect/web3-provider";
import { useUserAddress } from "eth-hooks";
import { formatEther, parseEther } from "@ethersproject/units";
import { useThemeSwitcher } from "react-css-theme-switcher";
import {
  useExchangePrice,
  useGasPrice,
  useUserProvider,
  useContractLoader,
  useContractReader,
  useEventListener,
  useBalance,
  useExternalContractLoader,
  useOnBlock,
} from "./hooks";
import { Header, Account, Faucet, Ramp, Contract, GasGauge, ThemeSwitch } from "./components";
import { Transactor } from "./helpers";
import { Hints, ExampleUI, Subgraph } from "./views";
import { INFURA_ID, DAI_ADDRESS, DAI_ABI, NETWORK, NETWORKS } from "./constants";

const axios = require("axios");

// const serverUrl = "https://backend.ether.delivery:49832/"
const serverUrl = "http://localhost:49832/";

/// üì° What chain are your contracts deployed to?
const targetNetwork = NETWORKS.rinkeby; // <------- select your target frontend network (localhost, rinkeby, xdai, mainnet)

// üò¨ Sorry for all the console logging
const DEBUG = true;

// üõ∞ providers
if (DEBUG) console.log("üì° Connecting to Rinkeby Ethereum");

const scaffoldEthProvider = new StaticJsonRpcProvider("https://rpc.scaffoldeth.io:48544");
const mainnetInfura = new StaticJsonRpcProvider("https://mainnet.infura.io/v3/" + INFURA_ID);
// ( ‚ö†Ô∏è Getting "failed to meet quorum" errors? Check your INFURA_I

// üè† Your local provider is usually pointed at your local blockchain
const localProviderUrl = targetNetwork.rpcUrl;
// as you deploy to other networks you can set REACT_APP_PROVIDER=https://dai.poa.network in packages/react-app/.env
const localProviderUrlFromEnv = process.env.REACT_APP_PROVIDER ? process.env.REACT_APP_PROVIDER : localProviderUrl;
if (DEBUG) console.log("üè† Connecting to provider:", localProviderUrlFromEnv);
const localProvider = new StaticJsonRpcProvider(localProviderUrlFromEnv);

// üî≠ block explorer URL
const blockExplorer = targetNetwork.blockExplorer;

function App(props) {
  const mainnetProvider = scaffoldEthProvider && scaffoldEthProvider._network ? scaffoldEthProvider : mainnetInfura;

  const [injectedProvider, setInjectedProvider] = useState();
  /* üíµ This hook will get the price of ETH from ü¶Ñ Uniswap: */
  const price = useExchangePrice(targetNetwork, mainnetProvider);

  /* üî• This hook will get the price of Gas from ‚õΩÔ∏è EtherGasStation */
  const gasPrice = useGasPrice(targetNetwork, "fast");
  // Use your injected provider from ü¶ä Metamask or if you don't have it then instantly generate a üî• burner wallet.
  const userProvider = useUserProvider(injectedProvider, localProvider);
  const address = useUserAddress(userProvider);

  // You can warn the user if you would like them to be on a specific network
  const localChainId = localProvider && localProvider._network && localProvider._network.chainId;
  const selectedChainId = userProvider && userProvider._network && userProvider._network.chainId;

  // For more hooks, check out üîóeth-hooks at: https://www.npmjs.com/package/eth-hooks

  // The transactor wraps transactions and provides notificiations
  const tx = Transactor(userProvider, gasPrice);

  // Faucet Tx can be used to send funds from the faucet
  const faucetTx = Transactor(localProvider, gasPrice);

  // üèó scaffold-eth is full of handy hooks like this one to get your balance:
  const yourLocalBalance = useBalance(localProvider, address);

  // If you want to call a function on a new block
  useOnBlock(mainnetProvider, () => {
    console.log(`‚õì A new mainnet block is here: ${mainnetProvider._lastBlockNumber}`);
  });

  // üß´ DEBUG üë®üèª‚Äçüî¨
  //
  useEffect(() => {
    if (
      DEBUG &&
      mainnetProvider &&
      address &&
      selectedChainId &&
      yourLocalBalance /* &&  yourMainnetBalance &&readContracts && writeContracts && mainnetDAIContract */
    ) {
      console.log("_____________________________________ üèó scaffold-eth _____________________________________");
      console.log("üåé mainnetProvider", mainnetProvider);
      console.log("üè† localChainId", localChainId);
      console.log("üë©‚Äçüíº selected address:", address);
      console.log("üïµüèª‚Äç‚ôÇÔ∏è selectedChainId:", selectedChainId);
      console.log("üíµ yourLocalBalance", yourLocalBalance ? formatEther(yourLocalBalance) : "...");
    }
  }, [
    mainnetProvider,
    address,
    selectedChainId,
    yourLocalBalance /* yourMainnetBalance, readContracts, writeContracts, mainnetDAIContract */,
  ]);

  let networkDisplay = "";
  if (localChainId && selectedChainId && localChainId != selectedChainId) {
    networkDisplay = (
      <div style={{ zIndex: 2, position: "absolute", right: 0, top: 0, padding: 16 }}>
        <Alert
          message="‚ö†Ô∏è Wrong Network"
          description={
            <div>
              You have <b>{NETWORK(selectedChainId).name}</b> selected and you need to be on{" "}
              <b>{NETWORK(localChainId).name}</b>.
            </div>
          }
          type="error"
          closable={false}
        />
      </div>
    );
  } else {
    networkDisplay = (
      <div style={{ zIndex: -1, position: "absolute", right: 154, top: 8, padding: 16, color: targetNetwork.color }}>
        {targetNetwork.name}
      </div>
    );
  }

  const loadWeb3Modal = useCallback(async () => {
    const provider = await web3Modal.connect();
    setInjectedProvider(new Web3Provider(provider));
  }, [setInjectedProvider]);

  useEffect(() => {
    if (web3Modal.cachedProvider) {
      loadWeb3Modal();
    }
  }, [loadWeb3Modal]);

  const [route, setRoute] = useState();
  useEffect(() => {
    setRoute(window.location.pathname);
  }, [setRoute]);

  let faucetHint = "";
  const faucetAvailable = localProvider && localProvider.connection && targetNetwork.name == "localhost";

  const [faucetClicked, setFaucetClicked] = useState(false);
  if (
    !faucetClicked &&
    localProvider &&
    localProvider._network &&
    localProvider._network.chainId == 31337 &&
    yourLocalBalance &&
    formatEther(yourLocalBalance) <= 0
  ) {
    faucetHint = (
      <div style={{ padding: 16 }}>
        <Button
          type="primary"
          onClick={() => {
            faucetTx({
              to: address,
              value: parseEther("0.01"),
            });
            setFaucetClicked(true);
          }}
        >
          üí∞ Grab funds from the faucet ‚õΩÔ∏è
        </Button>
      </div>
    );
  }

  const isSigner = injectedProvider && injectedProvider.getSigner && injectedProvider.getSigner()._isSigner;

  const [loading, setLoading] = useState();

  const [result, setResult] = useState();

  let display = "";
  if (result) {
    let possibleTxId = result.substr(-66);
    console.log("possibleTxId", possibleTxId);
    let extraLink = "";
    if (possibleTxId.indexOf("0x") == 0) {
      extraLink = (
        <a href={blockExplorer + "tx/" + possibleTxId} target="_blank">
          view transaction on etherscan
        </a>
      );
    } else {
      possibleTxId = "";
    }
    // ADD NEWS  PAGE
    display = (
      <div style={{ marginTop: 32 }}>
        {result}  
      </div>
      
    );
  } else if (isSigner) {
    display = (
      <Button
        loading={loading}
        style={{ marginTop: 32 }}
        type="primary"
        onClick={async () => {
          setLoading(true);
          try {
            const message = `Hi, ${address} Sign On This Dapp!`
            if(message.length > 0) {
            const sig = await userProvider.send("personal_sign", [message, address]);
            console.log("sig", sig);
            // const msgToSign = await axios.get(serverUrl);
      
            // console.log("msgToSign", msgToSign);
            // if (msgToSign.data && msgToSign.data.length > 32) {
            //   // <--- traffic escape hatch?
            //   let currentLoader = setTimeout(() => {
            //     setLoading(false);
            //   }, 4000);
            //   const message = msgToSign.data.replace("**ADDRESS**", address);
            //   const sig = await userProvider.send("personal_sign", [message, address]);
            //   clearTimeout(currentLoader);
            //   currentLoader = setTimeout(() => {
            //     setLoading(false);
            //   }, 4000);
            //   console.log("sig", sig);
              // const res = await axios.post(serverUrl, {
              //   address,
              //   message,
              //   signature: sig,
              // });
              let currentLoader = setTimeout(() => {
              setLoading(false);
              }, 4000);
              clearTimeout(currentLoader);
              setLoading(false);
              // console.log("RESULT:", res);
              // TODO  serverless 
              // if (res.data) {
              //   setResult(res.data);
              // }
              setResult("Web3 Sign OK!")  
            } else {
              setLoading(false);
              setResult("üòÖ Sorry, the server is overloaded. Please try again later. ‚è≥");
            }
          } catch (e) {
            message.error(" Sorry, the server is overloaded. üßØüöíüî•");
            console.log("FAILED TO GET...");
          }
        }}
      >
        <span style={{ marginRight: 8 }}>üîè</span> sign a message with your ethereum wallet
      </Button>
    );
  }

  return (
    <div className="App">
      {/* ‚úèÔ∏è Edit the header and change the title to your project name */}
      <Header />

      {networkDisplay}

      <ThemeSwitch />

      {/* üë®‚Äçüíº Your account is in the top right with a wallet at connect options */}
      <div style={{ textAlign: "center", padding: 10 }}>
        <Account
          connectText="Connect Ethereum Wallet"
          onlyShowButton={!isSigner}
          address={address}
          localProvider={localProvider}
          userProvider={userProvider}
          mainnetProvider={mainnetProvider}
          price={price}
          web3Modal={web3Modal}
          loadWeb3Modal={loadWeb3Modal}
          logoutOfWeb3Modal={logoutOfWeb3Modal}
          blockExplorer={blockExplorer}
        />
        {faucetHint}
      </div>
      {display}
    </div>
  );
}

/*
  Web3 modal helps us "connect" external wallets:
*/
const web3Modal = new Web3Modal({
  // network: "mainnet", // optional
  cacheProvider: true, // optional
  providerOptions: {
    walletconnect: {
      package: WalletConnectProvider, // required
      options: {
        infuraId: INFURA_ID,
      },
    },
  },
});

const logoutOfWeb3Modal = async () => {
  await web3Modal.clearCachedProvider();
  setTimeout(() => {
    window.location.reload();
  }, 1);
};

window.ethereum &&
  window.ethereum.on("chainChanged", chainId => {
    web3Modal.cachedProvider &&
      setTimeout(() => {
        window.location.reload();
      }, 1);
  });

window.ethereum &&
  window.ethereum.on("accountsChanged", accounts => {
    web3Modal.cachedProvider &&
      setTimeout(() => {
        window.location.reload();
      }, 1);
  });

export default App;
